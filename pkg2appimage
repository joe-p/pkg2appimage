#!/usr/bin/env bash

HERE="$(dirname "$(readlink -f "${0}")")"

export PATH="${HERE}"/usr/bin/:"${HERE}"/usr/sbin/:"${HERE}"/usr/games/:"${HERE}"/bin/:"${HERE}"/sbin/:"${PATH}"
export LD_LIBRARY_PATH="${HERE}"/usr/lib/:"${HERE}"/usr/lib/i386-linux-gnu/:"${HERE}"/usr/lib/x86_64-linux-gnu/:"${HERE}"/usr/lib32/:"${HERE}"/usr/lib64/:"${HERE}"/lib/:"${HERE}"/lib/i386-linux-gnu/:"${HERE}"/lib/x86_64-linux-gnu/:"${HERE}"/lib32/:"${HERE}"/lib64/:"${LD_LIBRARY_PATH}"
export XDG_DATA_DIRS="${HERE}"/usr/share/:"${XDG_DATA_DIRS}"


# Specify a certain commit if you do not want to use master
# by using:
# export PKG2AICOMMIT=<git sha>
if [ -z "$PKG2AICOMMIT" ] ; then
  PKG2AICOMMIT=master
fi

usage() {
  if [ -z "$APPIMAGE" ]  ; then
    MYSELF="$0"
  else
    MYSELF="$APPIMAGE"
  fi
  echo "usage:"
  echo "  $MYSELF [--di] META-NAME|YAMLFILE"
  echo ""
  echo "options:"
  echo "  --di    enable legacy desktop integration (unsupported)"
  exit 1
}

check_dependencies() {
  for executable in $@; do
    which "${executable}" >/dev/null 2>&1 || {
      (echo "${executable} missing"; exit 1)
    }
  done
}

if [ $# -eq 0 ] || [ "x${!#}" = "x--di" ] ; then
  usage
fi
if [ $# -eq 2 ] && [ "x$1" != "x--di" ] ; then
  usage
fi

if [ "x$1" = "x--di" ] ; then
  ENABLE_DI="yes"
else
  ENABLE_DI="no"
fi

# Halt on errors
set -e
set -x

# Check dependencies
check_dependencies \
  convert \
  wget \
  grep \
  sed \
  cut \
  file \
  desktop-file-validate \
  strings


YAMLFILE=$(readlink -f "${!#}")


# Lightweight bash-only dpkg-scanpackages replacement
scanpackages() {
  for deb in *.deb ; do
    dpkg -I $deb | sed 's/^ *//g' | grep -i -E '(package|version|installed-size|architecture|depends|priority):'
    echo "Filename: $(readlink -f $deb)"
    echo "MD5sum: $(md5sum -b $deb | cut -d' ' -f1)"
    echo "SHA1: $(sha1sum -b $deb | cut -d' ' -f1)"
    echo "SHA256: $(sha256sum -b $deb | cut -d' ' -f1)"
    echo
  done
}

# Function to parse yaml
# https://gist.github.com/epiloque/8cf512c6d64641bde388
# based on https://gist.github.com/pkuczynski/8665367
parse_yaml() {
    local prefix=$2
    local s
    local w
    local fs
    s='[[:blank:]]*'
    w='[a-zA-Z0-9_]*'
    fs="$(echo @|tr @ '\034')"
    sed -ne "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" "$1" |
    awk -F"$fs" '{
    indent = length($1)/2;
    vname[indent] = $2;
    for (i in vname) {if (i > indent) {delete vname[i]}}
        if (length($3) > 0) {
            vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("_")}
            printf("%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, $3);
        }
    }' | sed 's/_=/+=/g'
}

# Read yaml file
parse_yaml $YAMLFILE "_"
eval $(parse_yaml $YAMLFILE "_")

if [ ! -z $_enable_di ]; then
    ENABLE_DI="$_enable_di"
fi

# Execute multiple script lines together as one
# shell_execute filename key_of_group_of_commands
shell_execute() {
  if [ -f /tmp/recipe_script ] ; then
    rm /tmp/recipe_script
  fi
  parse_yaml $YAMLFILE "_" | grep "^$2+=" > /tmp/recipe_script
  sed -i -e 's|^'$2'+=("||g' /tmp/recipe_script
  sed -i -e 's|")$||g' /tmp/recipe_script
  bash -ex /tmp/recipe_script
  rm /tmp/recipe_script
}

APP=$_app
LOWERAPP=${APP,,}
if [ ! -z $_lowerapp ] ; then
  LOWERAPP=$_lowerapp
fi

mkdir -p ./$APP/$APP.AppDir/usr/lib
cd ./$APP/

if [ -d "./$APP.AppDir/" ] ; then
  rm -rf ./$APP.AppDir/
fi

if [ -z "$FUNCTIONS_SH" ] ; then
  . ../functions.sh
else
  if [ -e "$FUNCTIONS_SH" ] ; then
    . "$FUNCTIONS_SH"
  fi
fi

# If there is an ARCH environment variable, then use that
# architecture to for apt-get. Not that for the AppImage to be
# operable, we also need to embed a matching AppImage runtime
# and ingredients of that architecture. Debian packages
# should be available for most architectures, e.g., oldstable
# has "armhf"
if [ ! -z "$ARCH" ] ; then
  OPTIONS="$OPTIONS -o APT::Architecture=$ARCH"
fi

if [ ! -z "${_ingredients_script[0]}" ] ; then
  # Execute extra steps defined in recipe
  shell_execute $YAMLFILE _ingredients_script
fi

if [ ! -z "${_ingredients_post_script[0]}" ] ; then
  # Execute extra steps defined in recipe
  shell_execute $YAMLFILE _ingredients_post_script
fi

mkdir -p ./$APP.AppDir/
cd ./$APP.AppDir/

mkdir -p usr/bin usr/lib

unset LD_PRELOAD

# Try to copy icons to standard locations where appimaged can pick them up
mkdir -p usr/share/icons/hicolor/{22x22,24x24,32x32,48x48,64x64,128x128,256x256,512x512}/apps/
find . -path *icons* -path *22* -name "*$LOWERAPP*" -exec cp {} usr/share/icons/hicolor/22x22/apps/ \; || true
find . -path *icons* -path *24* -name "*$LOWERAPP*" -exec cp {} usr/share/icons/hicolor/24x24/apps/ \; || true
find . -path *icons* -path *32* -name "*$LOWERAPP*" -exec cp {} usr/share/icons/hicolor/32x32/apps/ \; || true
find . -path *icons* -path *48* -name "*$LOWERAPP*" -exec cp {} usr/share/icons/hicolor/48x48/apps/ \; || true
find . -path *icons* -path *64* -name "*$LOWERAPP*" -exec cp {} usr/share/icons/hicolor/64x64/apps/ \; || true
find . -path *icons* -path *128* -name "*$LOWERAPP*" -exec cp {} usr/share/icons/hicolor/128x128/apps/ \; || true
find . -path *icons* -path *256* -name "*$LOWERAPP*" -exec cp {} usr/share/icons/hicolor/256x256/apps/ \; || true
find . -path *icons* -path *512* -name "*$LOWERAPP*" -exec cp {} usr/share/icons/hicolor/512x512/apps/ \; || true

get_icon

if [ -z "${_union}" ] ; then
  cp ../../AppRun* ./AppRun
else
cat > AppRun <<\EOF
#!/bin/sh
HERE="$(dirname "$(readlink -f "${0}")")"
export UNION_PRELOAD="${HERE}"
export LD_PRELOAD="${HERE}/libunionpreload.so"
export PATH="${HERE}"/usr/bin/:"${HERE}"/usr/sbin/:"${HERE}"/usr/games/:"${HERE}"/bin/:"${HERE}"/sbin/:"${PATH}"
export LD_LIBRARY_PATH="${HERE}"/usr/lib/:"${HERE}"/usr/lib/i386-linux-gnu/:"${HERE}"/usr/lib/x86_64-linux-gnu/:"${HERE}"/usr/lib32/:"${HERE}"/usr/lib64/:"${HERE}"/lib/:"${HERE}"/lib/i386-linux-gnu/:"${HERE}"/lib/x86_64-linux-gnu/:"${HERE}"/lib32/:"${HERE}"/lib64/:"${LD_LIBRARY_PATH}"
export PYTHONPATH="${HERE}"/usr/share/pyshared/:"${PYTHONPATH}"
export PYTHONHOME="${HERE}"/usr/
export XDG_DATA_DIRS="${HERE}"/usr/share/:"${XDG_DATA_DIRS}"
export PERLLIB="${HERE}"/usr/share/perl5/:"${HERE}"/usr/lib/perl5/:"${PERLLIB}"
export GSETTINGS_SCHEMA_DIR="${HERE}"/usr/share/glib-2.0/schemas/:"${GSETTINGS_SCHEMA_DIR}"
export QT_PLUGIN_PATH="${HERE}"/usr/lib/qt4/plugins/:"${HERE}"/usr/lib/i386-linux-gnu/qt4/plugins/:"${HERE}"/usr/lib/x86_64-linux-gnu/qt4/plugins/:"${HERE}"/usr/lib32/qt4/plugins/:"${HERE}"/usr/lib64/qt4/plugins/:"${HERE}"/usr/lib/qt5/plugins/:"${HERE}"/usr/lib/i386-linux-gnu/qt5/plugins/:"${HERE}"/usr/lib/x86_64-linux-gnu/qt5/plugins/:"${HERE}"/usr/lib32/qt5/plugins/:"${HERE}"/usr/lib64/qt5/plugins/:"${QT_PLUGIN_PATH}"
EXEC=$(grep -e '^Exec=.*' "${HERE}"/*.desktop | head -n 1 | cut -d "=" -f 2- | sed -e 's|%.||g')
exec ${EXEC} "$@"
EOF
fi

chmod a+x ./AppRun


get_desktop

# Prevent Qt from loading plugins from the system
unset QTPATH
QTPATH=$(find usr/lib -type d -name qt4 -or -name qt5 | sed -e 's|usr/|../|g')
if [ ! -z $QTPATH ] ; then
cat > usr/bin/qt.conf <<EOF
[Paths]
Prefix = $QTPATH
EOF
fi

# http://www.mono-project.com/docs/advanced/assemblies-and-the-gac/
# At runtime, Mono looks in three places for assemblies necessary
# to run a program. It first searches the location of the executing assembly.
# For this to work without setting $MONO_PATH, we need to move the
# main *.exe to usr/lib/mono/exe, because we move all "assemblies" (sic)
# there in this script

if [ -e usr/lib/mono ] ; then
  # Force all so files referenced in config files into LD_LIBRARY_PATH
  find . -name "*.dll.config" -exec cat {} > temp \;
  # Remove all absolute paths
  sed -i -E 's|target=\"\/(.*\/)([a-z0-9].*?)>|target=\"\2>|g' temp
  SONAMES=$(cat temp | cut -d '"' -f 4  | grep ".so" || true)
  if [ "" != "$SONAMES" ] ; then
    for SONAME in $SONAMES; do
      find . -name "$SONAME" -exec mv {} usr/lib \;
    done
  fi
  rm temp
  PATH_OF_THE_EXE="usr/lib/mono/exe"
  mkdir -p "$PATH_OF_THE_EXE"
  # Force all dll files into PATH_OF_THE_EXE (or MONO_PATH which we would have to set)
  find . -name "*.dll" -and -not -name "mscorlib.dll" -exec mv {} "$PATH_OF_THE_EXE" \;
  # Edit all config files in place to remove absolute paths
  find . -name "*.dll.config" -exec sed -i -E 's|target=\"\/(.*\/)([a-z0-9].*?)>|target=\"\2>|g' {} \;
  # Force all config files into the PATH_OF_THE_EXE (or MONO_PATH which we would have to set)
  find . -name "*.dll.config" -exec mv {} "$PATH_OF_THE_EXE" \;
  # Remove gac, we are not using it since it is convoluted
  rm -rf usr/lib/mono/gac/
fi

if [ -d "./usr/lib/x86_64-linux-gnu/gstreamer-1.0/" ] ; then
  mv ./usr/lib/x86_64-linux-gnu/gstreamer-1.0/* ./usr/lib/x86_64-linux-gnu/
  rm -r ./usr/lib/x86_64-linux-gnu/gstreamer-1.0
fi

if [ -d "./usr/lib/x86_64-linux-gnu/pulseaudio/" ] ; then
  mv ./usr/lib/x86_64-linux-gnu/pulseaudio/* ./usr/lib/x86_64-linux-gnu/
  rm -r ./usr/lib/x86_64-linux-gnu/pulseaudio
fi

# Execute extra steps defined in recipe
if [ ! -z "${_script}" ] ; then
  shell_execute $YAMLFILE _script
fi

DESKTOP=$(find . -name '*.desktop' | sort | head -n 1)

# desktop-file-validate complains about missing trailing semicolons for some
# keys although the format definition says that they are optional
fix_desktop "$DESKTOP"

# Some non-distribution provided applications have an absolute
# path in the Exec= line which we remove for relocateability
if [ -z "$DESKTOP" ] ; then
  echo "desktop file not found, aborting"
  exit 1
else
  desktop-file-validate "$DESKTOP" || exit 1
  ORIG=$(grep -o "^Exec=.*$" "${DESKTOP}" | head -n 1| cut -d " " -f 1)
  REPL=$(basename $(grep -o "^Exec=.*$" "${DESKTOP}" | head -n 1 | cut -d " " -f 1 | sed -e 's|Exec=||g'))
  sed -i -e 's|'"${ORIG}"'|Exec='"${REPL}"'|g' "${DESKTOP}"
fi

# Compile GLib schemas if the subdirectory is present in the AppImage
# AppRun has to export GSETTINGS_SCHEMA_DIR for this to work
if [ -d usr/share/glib-2.0/schemas/ ] ; then
  ( cd usr/share/glib-2.0/schemas/ ; glib-compile-schemas . )
fi

if [ -f ../VERSION ] ; then
  VERSION=$(cat ../VERSION)
else
  get_version || true
fi

# patch_usr
# Patching only the executable files seems not to be enough for some apps
if [ ! -z "${_binpatch}" ] ; then
  find usr/ -type f -exec sed -i -e 's|/usr|././|g' {} \;
  find usr/ -type f -exec sed -i -e 's@././/bin/env@/usr/bin/env@g' {} \;
fi

# Don't suffer from NIH; use LD_PRELOAD to override calls to /usr paths
if [ ! -z "${_union}" ] ; then
  mkdir -p usr/src/
  wget -q "https://raw.githubusercontent.com/mikix/deb2snap/master/src/preload.c" -O - | \
  sed -e 's|SNAPPY|UNION|g' | sed -e 's|SNAPP|UNION|g' | sed  -e 's|SNAP|UNION|g' | \
  sed -e 's|snappy|union|g' > usr/src/libunionpreload.c
  gcc -shared -fPIC usr/src/libunionpreload.c -o libunionpreload.so -ldl -DUNION_LIBNAME=\"libunionpreload.so\"
  strip libunionpreload.so
fi

delete_blacklisted

if [ "$ENABLE_DI" = "yes" ] ; then
  get_desktopintegration $LOWERAPP
fi

# Fix desktop files that have file endings for icons
sed -i -e 's|\.png||g' *.desktop || true
sed -i -e 's|\.svg||g' *.desktop || true
sed -i -e 's|\.svgz||g' *.desktop || true
sed -i -e 's|\.xpm||g' *.desktop || true

# Setting PYTHONHOME instead
# Fix Python imports,
# https://github.com/AppImage/AppImages/issues/172
# SITECUSTOMIZEFILES=$(find . -name "sitecustomize.py")
# for SITECUSTOMIZEFILE in $SITECUSTOMIZEFILES ; do
# rm $SITECUSTOMIZEFILE # Remove symlinks, replace by files
# cat > $SITECUSTOMIZEFILE <<\EOF
# import sys,os
# if sys.version_info[0] < 3:
#     prefix = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(sys.path[0]))))
#     sys.path = [ prefix+s for s in sys.path if not s.startswith(prefix) ]
# EOF
# done

# Execute extra steps defined in recipe
if [ ! -z "${_post_script[0]}" ] ; then
  shell_execute $YAMLFILE _post_script
fi

# Go out of AppImage
cd ..

if [ -z "${_updateinformation}" ] ; then
  generate_type2_appimage
else
  generate_type2_appimage -u "${_updateinformation}"
fi

ls -lh ../out/*.AppImage
